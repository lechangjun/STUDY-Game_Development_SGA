#### Event Loop

* 이벤트 루프(Event Loop): 메시지를 대기하다가 받으면 루프를 돌면서 해당 이벤트를 처리한다. 
* 사용자가 발생시키거나, 위젯에서 발생시킨 이벤트들이 순서대로 Event Queue에 입력된다.
* 메인 이벤트 루프는 Event Queue로부터 순차적으로 이벤트를 가져간 후, 해당 이벤트를 처리할 메소드를 호출하여 이벤트를 처리한다.
* Queue이기 때문에 순차적으로 처리된다.
* ex) 로그인이 완료될 때까지 다른 코드가 수행되지 않고 기다려야 하는 경우



#### QEventLoop

* QEventLoop 객체를 만들고, QEventLoop::exec()을 호출하면 이벤트 루프가 시작된다.
* 이벤트 루프에서 빠져나가고 싶을 때는 QEventLoop::exit()를 호출한다.
* signal/slot과 함께 이용하면 편리하다.



#### 메모

> GUI 스레드가 아닌 다른 스레드에서 얼럿의 정보를 가져와야 했다.
>
> UI 컨트롤은 GUI 스레드에서만 할 수 있기 때문에, signal과 slot을 이용하여 특정 신호를 주고받는 것까지는 떠올랐었다.
>
> 이미 충분히 큰 사이즈의 클래스이다 보니까 새로운 변수를 추가해서 컨트롤하는 건 아니라고 판단했다. 따라서 기존에도 flag 변수를 이용해서 while문을 돌고 있는 상황이었는데, 여기에 GUI 스레드 쪽 flag 변수를 가져다가 체크할 수 있게끔 조건문 몇 개를 변경해 버렸다. 
>
> 그리고 이 작업을 하면서 스레드 간의 정보 갱신 텀이 있는 것을 발견했기 때문에 Sleep을 걸어서 조금 딜레이를 주었다.
>
> 
>
> 선배는 이 방법을 QEventLoop를 사용하여 코딩하셨다.
>
> 내 코드처럼 flag를 덕지덕지 붙인 while문이 아니라, 기존 while문에 QEventLoop를 시작하면서 특정 signal이 들어오면 QEventLoop::exit slot을 이용하여 해당 이벤트 루프를 빠져나오는 방식의 코드를  추가하셨다.
>
> 이때 이벤트 루프를 어떻게 사용하는지, 그리고 이렇게 점점 flag 변수가 많아지면 컨트롤하기 어렵고 좋지 않은 코드라는 것을 알게 되었다.
>
> 현재는 flag 변수를 선언하기 전에 고민, 또 고민을 하고 있다.